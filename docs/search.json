[
  {
    "objectID": "test_cases.html",
    "href": "test_cases.html",
    "title": "Test Cases",
    "section": "",
    "text": "This page provides some commentary on the test cases the agreed upon behaviour of the program in each case. The test cases are located in the GitHub project files.",
    "crumbs": [
      "Test Cases"
    ]
  },
  {
    "objectID": "test_cases.html#this-page",
    "href": "test_cases.html#this-page",
    "title": "Test Cases",
    "section": "",
    "text": "This page provides some commentary on the test cases the agreed upon behaviour of the program in each case. The test cases are located in the GitHub project files.",
    "crumbs": [
      "Test Cases"
    ]
  },
  {
    "objectID": "test_cases.html#case-a",
    "href": "test_cases.html#case-a",
    "title": "Test Cases",
    "section": "Case A",
    "text": "Case A\nTest Case A (labelled GraphA in the test folder) is a simple network in form of an adjacency list. It is comprised of 4 nodes and 5 links, three links exist between nodes 2 and 3. Edge costs are in range [1,3].\n\n\n\nNetwork Graph of Case A. Nodes are numbered [0, 3] and weights/ costs are assigned to each link.\n\n\n\nShortest Paths\nSolving Case A using a single shortest path algorithm (SSSP) from Node 0 to each subsequent node gives the following results:\n\n\n\nDestination Node\nLowest Cost from Node 0\n\n\n\n\n0 (origin)\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n\n\n\nEfficient Routes\nUsing the not-too-long criterion with an elongation ratio of 1.6, the number of valid links and therefore efficient routes can be found. The validity of an efficient link can be determined using\n\\[\n\\begin{aligned}\nl_a \\leq (1+\\tau_r^a)(l_r(head_a)-l_r(tail_a))\n\\end{aligned}\n\\]\nwhere \\(l_a\\) is the link cost; \\(\\tau_r^a\\) is the elongation ration; \\(l_r(head_a)\\) and \\(l_r(tail_a)\\) are the shortest paths from origin to the head and tail nodes of the link, respectively. Each link in Case A can then be assessed. Between Nodes 0 and 1 there exists a single link:\n\\[\n1 \\leq (1+1.6)(1-0) \\\\\n1 \\leq 2.6 \\rightarrow \\text{OK}\n\\]\nTherefore the link is valid. Three links exist between Nodes 1 and 2 and so:\n\\[\n\\begin{aligned}1 \\leq (1+1.6)(2-1) \\rightarrow \\text{OK} \\\\\n2 \\leq (1+1.6)(2-1) \\rightarrow \\text{OK} \\\\\n3 \\nleq (1+1.6)(2-1) \\rightarrow \\text{Fails}\\end{aligned}\n\\]\nTherefore only 2 links with costs 1 and 2 are valid using the set criterion. The same repeats for all remaining nodes. The result is for Case A is four links between four nodes (but three OD pairs). Visually, the network now appears as:\n\n\n\nGraph A subnetwork with not-too-long routes (solid lines) and removed nodes (dashed line)",
    "crumbs": [
      "Test Cases"
    ]
  },
  {
    "objectID": "test_cases.html#case-b",
    "href": "test_cases.html#case-b",
    "title": "Test Cases",
    "section": "Case B",
    "text": "Case B\nCase B is a more complex version of Case A; it features 5 nodes and 10 edges between nodes. Edge nodes are in range [1,3]. The graphical representation of Case B is presented below:\n\n\n\nNetwork Graph of Case B. Nodes are numbered [0,5] and edge costs are assigned to each edge link.\n\n\nSolving the SSSP from using Node 0 as the origin to all other nodes in the network results in the following origin-destination costs:\n\n\n\nDestination Node\nCost\n\n\n\n\n0 (Origin)\n0\n\n\n1\n1\n\n\n2\n4\n\n\n3\n2\n\n\n4\n3\n\n\n5\n4",
    "crumbs": [
      "Test Cases"
    ]
  },
  {
    "objectID": "test_cases.html#case-c",
    "href": "test_cases.html#case-c",
    "title": "Test Cases",
    "section": "Case C",
    "text": "Case C\nCase C is a simple network which has several efficient paths for a given OD pair. It contains 6 nodes and 7 links. Free flow travel time are in range [4,12].",
    "crumbs": [
      "Test Cases"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "This page details the functionality and methods used in the program. It is intended to provide enough detail to understand the thinking and progression of the program, or to enable a user to extract or re-purpose individual methods or classes.",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#this-page",
    "href": "functions.html#this-page",
    "title": "Functions",
    "section": "",
    "text": "This page details the functionality and methods used in the program. It is intended to provide enough detail to understand the thinking and progression of the program, or to enable a user to extract or re-purpose individual methods or classes.",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#inputs",
    "href": "functions.html#inputs",
    "title": "Functions",
    "section": "Inputs",
    "text": "Inputs\n\nParameter input\nThe program commences with a call to analyse_network(.) which takes the following arguments:\n\n\n\n\n\n\n\nstart_nodes\nan integer or set of integers (space separated) specifying the origin or start nodes for which to compute from\n\n\nstart_index\nthe starting index of the adjacency list, either 0 or 1\n\n\ninput_path\nthe file path to the adjacency list (a text file)\n\n\ncompute_route_diversity\nBoolean to compute the route diversity (i.e.¬†the number of unique routes between nodes)\n\n\ncompute_link_usage\nBoolean to compute the link usage (i.e.¬†the number of routes that utilise a link)\n\n\nshould_write_results\nBoolean to write the resulting matrix/ matrices to a JSON and subnetwork adjacency list to a text file\n\n\noutput_dir\nthe output directory for the results to be written to (if user_specified_write_results is TRUE, else output_dir can be set NULL)\n\n\n\nNote that this program assesses single origin paths only. Early versions of the program allowed multiple origin nodes to be specified at initialisation, however this functionality was removed for performance reasons. A similar function process_link_usage_only(.) exists which only computes the link usage and does not compute the efficient routes. This is for cases where the efficient routes matrix is pre-computed and can be loaded by the program.\n\n\nCommand Line Interface\n\n\n\n\n\n\nNote\n\n\n\nThe current implementation does not take an input for the output directory (output_dir). Instead the directory of the input file is used by default. Users wishing to specify a different output directory should use a direct function call.\n\n\nThe function test_initialiser(.) can be called directly, but it is expected most users will initialise the program using the Command Line Interface (CLI) which collects the user‚Äôs responses and passes them to test_initialiser(.). Under normal execution, the CLI is called from the main() function which will collect the user‚Äôs inputs using helper functions which enforce input class requirements and excepts any invalid inputs.\nsee also:\n\nInput adjacency list\nOutputs\n\n\n\nInput adjacency list\nThe input path for the program should point to a text file containing the adjacency list for the network of interest. The adjacency list should contain the network links, one per line, in the format [origin destination cost]. The nodes and costs must be space seperated. An example from Test Graph A is presented below:\n0 1 1\n1 2 1\n1 2 2\n1 2 3\n2 3 1\n\n\n\n\n\n\nNote\n\n\n\nOnly static costs can be considered by this program. It is not currently possible to consider dynamic costs such as those used for route assignment (e.g.¬†The Bureau of Public Roads (BPR) function). It is recommended that the user use the free flow travel time or segment length if a free flow time is not available for a network.\n\n\n\n\nData types\nOnce the input files are read they are stored in a the custom data structure network_map which contain the data class Edge. See the Data Structures page for details on the implementation and structure of these data structures.",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#roadnetwork-class",
    "href": "functions.html#roadnetwork-class",
    "title": "Functions",
    "section": "RoadNetwork Class",
    "text": "RoadNetwork Class\nOnce initialised, the program executes its core functionality using the RoadNetwork Class which contains the network information and functions to complete the program computations. The following sections contain an overview of the RoadNetwork Class functions.\n\nsssp_dijkstra_solver(.)\nThis function solves the Single-Source Shortest Path (SSSP) problem using the Dijkstra algorithm. SSSP solves the shortest path from origin to all other nodes. sssp_dijkstra_solver(.) requires the following inputs:\n\n\n\n\n\n\n\nnode\nThe network origin node\n\n\nnetwork_map\nThe network graph, stored as structure network_map\n\n\nd\nAn initialised variable of type vector&lt;double&gt; which will contain the shortest paths for each node. This variable is stored in the RoadNetwork class.\n\n\n\n\n\nbuild_subnetwork(.)\n\n\n\n\n\n\nNote\n\n\n\nAt present, the elongation ratio for the not-too-long criteria is a globally defined variable set to 1.6. It is planned to allow this value to be user specified.\n\n\nThis function applies the short detour/ not-too-long criteria to the road network to subset the network to only nodes and links which meet the criteria.build_subnetwork(.) requires the following inputs:\n\n\n\n\n\n\n\nnetwork_map\nThe network graph, stored as structure network_map\n\n\nsubnetwork_map\nAn initialised variable of type subnetwork map which will contain the returned subsetted network graph, stored in the RoadNetwork Class\n\n\nd\nAn initialised variable of type vector&lt;double&gt; which will contain the shortest paths for each node. This variable is stored in the RoadNetwork Class. This variable is initialised by the program if run through the RoadNetwork Class - no user intervention required.\n\n\n\nThe not-too-long criterion is enforced using an elongation ratio, \\(\\tau^a_r\\), which typically ranges between 1.3 - 1.6 (this program uses 1.6 by default). The program uses the following mathematical expression to determine the sub-setted links and nodes:\n\\[(1+\\tau^a_r)(l_r(head_a) - l_r(tail_a))\\geq l_a\\] where \\(l_a\\) is the cost of link \\(a\\), \\(head_a\\) and \\(tail_a\\) are the head and tail of link \\(a\\), and \\(l_r(head_a)\\) and \\(l_r(tail_a)\\) are the cost from the origin \\(r\\) to the head and tail of the link, respectively.\n\n\nefficient_routes(.)\nThis function applies the efficient route calculations. It takes the following inputs:\n\n\n\n\n\n\n\nsubnetwork_map\nA variable of type subnetwork map which will contain the subsetted network graph, stored in the RoadNetwork Class\n\n\nindex\nAn integer specifying the starting index of the network nodes (0 or 1)\n\n\n\nefficient_routes(.) begins by converting the subnetwork from type subnetwork_map to an adjacency matrix. At current, only one link can exist between two nodes per direction. The adjacency matrix will be of size \\(n \\times n\\) , where \\(n\\) is the number of unique nodes in the subnetwork. The number of efficient routes is subsequently calculated using the following loop:\n    for (int j = 0; j &lt;= number of nodes; j++) {\n        for (int m = 0; m &lt;= number of nodes; m++) {\n            if (m == j) continue;\n            for (int n = 0; n &lt;= number of nodes; n++) {\n                if (n == j || n == m) continue;\n                LinkMatrix[m][n] += LinkMatrix[m][j] * LinkMatrix[j][n];\n            }\n        }\n    }\nThe result is a matrix containing the number of efficient routes between the specified origin and all nodes subsetted from the network.\n\n\n\n\n\n\nCaution\n\n\n\nThe required compute increases significantly with additional nodes in the network (algorithm is of order \\(O(n^3)\\) ). This will result in long compute times for large networks.\n\n\n\n\ncalculate_link_usage(.)\nThis function calculates the link usage for each link in the network. It takes the following inputs: | | | |‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-| | start_node | An integer specifying the origin node for which to calculate the link usage | | routes_matrix | A matrix containing the number of efficient routes between the origin node and all other nodes in the subnetwork | | node_index_map | A vector containing the mapping of node indices to their original indices in the input adjacency list |\nThe function iterates through the routes matrix and counts the number of times each link is used in the efficient routes. The result is a matrix containing the link usage for each link in the network.\nFor efficiency, simple matrix multiplication is not used. Instead, the valid links from the routes_matrix are pre-computed and iterated through. This reduces the total number of computations than would be required if the entire routes matrix was used.The basis for the calculation can be found in #assessing-link-usage.\nThe computational routine consists of:\n    // Iterate through all possible destination nodes 's' (using index)\n    for (std::int64_t s = 0; s &lt; total_nodes; ++s) {\n        if (r == s) continue; // Skip self-connections (compare indices)\n        // For each link in the network (using indices)\n        for (const auto& link : links) {\n            std::int64_t tail = link.tail; \n            std::int64_t head = link.head; \n            std::int64_t routes_to_tail = routes_matrix[r][tail];\n            std::int64_t routes_from_head = routes_matrix[head][s];\n\n            // Calculate usage only if both parts are non-zero\n            if (routes_to_tail &gt; 0 && routes_from_head &gt; 0) {\n                std::int64_t usage = routes_to_tail * routes_from_head;\n\n                // Convert matrix indices back to actual node IDs for the result structure\n                std::int64_t dest_id = index_to_node[s];\n                std::int64_t tail_id = index_to_node[tail];\n                std::int64_t head_id = index_to_node[head];\n\n                results.push_back({ origin_id, dest_id, tail_id, head_id, usage });\n            }\n        }\n    }",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#outputs",
    "href": "functions.html#outputs",
    "title": "Functions",
    "section": "Outputs",
    "text": "Outputs\nThe user has the option to save the results of the analysis when the program is initialised through test_initialiser(.). Two outputs are created when the user specifies results to be saved.\n\n\n\n\nwrite_link_matrix_json(.)\nThis function uses the JSON for Modern C++ library created by Nlohmann to save the result matrices as into a single JSON file. The JSON format provides flexibility in saving several matrices of different sizes within a single file which cannot easily be achieved using a text file, for example.\nThe write_link_matrix_json(.) function requires two inputs:\n\n\n\n\n\n\n\nresults\nThe link matrix to be written, where each row represents connections between nodes\n\n\noutput_path\na string specifying the output path (including file name and .JSON extension) for the results to be saved into\n\n\n\nCreates or overwrites a file at output_path. The file contains a pretty-printed JSON array, representing the matrix. When the program is called through the test_initialiser(.) function the output_path is set to the same directory as the input adjacency list. The file will be saved as ‚Äú{input graph name}_Results.json‚Äù\n\n\nwrite_subnetwork(.)\nThis function saves the subsetted network created from the build_subnetwork(.) function. It includes the links that meet the not-too-long criteria and is saved in the same format as the input adjacency list [origin destination cost]. The subsetted network is used in the efficient_routes(.). Saving the subnetwork is useful for visualising the results, debugging, or further analysis.\nThe function requires three inputs:\n\n\n\n\n\n\n\nstart_nodes\na vector of integers containing the user specified start nodes\n\n\nsubnetwork_maps\na vector containing the type subnetwork_map to store one or more subnetworks created from build_subnetwork(.).\n\n\noutput_path\na string specifying the output path (including file name and .JSON extension) for the results to be saved into\n\n\n\nThe subnetworks are saved as a text file. When the program is called through the test_initialiser(.) function the output_path is set to the same directory as the input adjacency list. The file will be saved as ‚Äú{input graph name}_SubNetwork.txt‚Äù\n\n\nwrite_link_usage(.)\nThis function Writes link usage statistics to a CSV text file. Inputs:\n\n\n\n\n\n\n\nlink_usage\nA vector containing link usage data, where each entry represents the usage count of a specific link (tail, head) for an origin-destination pair. Generated from the calculate_link_usage(.) function.\n\n\nfile_path\nA string specifying the output path (including file name and .CSV extension) for the results to be saved into.\n\n\n\nIt creates or overwrites a file at file_path. The file contains a header:\n\nEach subsequent line records the origin node, destination node, link tail, link head, and usage count, separated by commas.",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#exception-handling-and-expected-behaviours",
    "href": "functions.html#exception-handling-and-expected-behaviours",
    "title": "Functions",
    "section": "Exception handling and expected behaviours",
    "text": "Exception handling and expected behaviours\n&lt;I haven‚Äôt written this part yet üòÄ&gt;",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "citations.html",
    "href": "citations.html",
    "title": "Acknowledgements and Citations",
    "section": "",
    "text": "This program was written as part of a research project funded by blah blah blah. Program was written and developed by blah and blah, Blah blah.",
    "crumbs": [
      "Acknowledgements and Citations"
    ]
  },
  {
    "objectID": "citations.html#authorship",
    "href": "citations.html#authorship",
    "title": "Acknowledgements and Citations",
    "section": "",
    "text": "This program was written as part of a research project funded by blah blah blah. Program was written and developed by blah and blah, Blah blah.",
    "crumbs": [
      "Acknowledgements and Citations"
    ]
  },
  {
    "objectID": "data_structures.html",
    "href": "data_structures.html",
    "title": "Data Structures",
    "section": "",
    "text": "This page contains a high level look into the data structures used to store and process network links. It is intended to provide some high level insight into the storage of the network structure which is critical to understanding how the program operates.",
    "crumbs": [
      "Data Structures"
    ]
  },
  {
    "objectID": "data_structures.html#this-page",
    "href": "data_structures.html#this-page",
    "title": "Data Structures",
    "section": "",
    "text": "This page contains a high level look into the data structures used to store and process network links. It is intended to provide some high level insight into the storage of the network structure which is critical to understanding how the program operates.",
    "crumbs": [
      "Data Structures"
    ]
  },
  {
    "objectID": "data_structures.html#network-data-structures",
    "href": "data_structures.html#network-data-structures",
    "title": "Data Structures",
    "section": "Network Data Structures",
    "text": "Network Data Structures\n\nGraph Network Map (network_map)\nThe data structure network_map is an unordered map containing an unordered map of vector objects in the Edge structure.\n\nThe first (outer) unordered map has an integer index and represents the nodes within the network.\nThe second (inner) unordered map is associated with a first (outer) unordered map. It represents the neighbouring nodes of each initial node in the network. The unordered map contains a vector object.\nThe vector object is of type Edge and contains:\n\nThe initial node index\nThe neigbouring node index\nThe edge or link cost\n\n\nIn C++ the structure is initialised by. A representative diagram is also presented.\n std::unordered_map&lt;int, std::unordered_map&lt;int, std::vector&lt;Edge&gt;&gt;&gt; network_map;\nnetwork_map\n‚îú‚îÄ‚îÄ node1\n‚îÇ   ‚îú‚îÄ‚îÄ neighbour1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge2\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îú‚îÄ‚îÄ neighbour2\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge2\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ node2\n‚îÇ   ‚îú‚îÄ‚îÄ neighbour1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge2\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îú‚îÄ‚îÄ neighbour2\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge2\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ ...\n\n\nGraph Subnetwork Map (subnetwork_map)\nThe structure subnetwork_map is similar to that of Graph Network Map (network_map) except the final vector class is of type int. The Edge structure is not needed here as it is only necessary to store the edge or link costs that meet the specified efficient route criteria, no regard is given to the specific node pair.\nThe simplification of subnetwork_map saves computational time and storage in the construction and reading of the network when in use. It is constructed in C++ as follows:\nstd::unordered_map&lt;int, std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;&gt; subnetwork_map;\n\n\nGraph Network Edges (G)\nThe structure G contains the edge or link pairs between nodes. The first element represents the destination node. The second element represents the edge or link cost. The structure is used to store the provided adjacency list as it effectively stores the list of neighbouring nodes for each node in the graph.\nFor example:\nG[i] = [(j,w), (k,x)]\nThe pair (v,w) represents the link from node i to node j which has cost w. The node i also has another edge represented by pair (k,x) which corresponds to an edge between node i to node k with cost x.\nThe structure G is initialised by:\n std::vector&lt;std::pair&lt;int, int&gt;&gt; G[n] // Create 'n' number of nodes",
    "crumbs": [
      "Data Structures"
    ]
  },
  {
    "objectID": "data_structures.html#custom-structures",
    "href": "data_structures.html#custom-structures",
    "title": "Data Structures",
    "section": "Custom Structures",
    "text": "Custom Structures\n\nEdge\nThe Edge structure contains information about each edge or link between two nodes:\nstruct Edge {\n    int u; // Start node\n    int v; // End node\n    int cost; // Cost of edge\n    int usage_counter = 0; // number of times edge is used in an efficent route\n};\nThe usage_counter is initially set to 0 and is incremented only when calculating the number of times a link is used when finding the efficient routes through the network.",
    "crumbs": [
      "Data Structures"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "This page covers the functionality and theory behind the Travel Route Diversity program. Each subsection introduces an aspect of the program‚Äôs function and discusses how the program approaches the problem. A high-level summary is provided in the project README, and an introduction to the method‚Äôs theory is presented in the Motivation section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#this-page",
    "href": "index.html#this-page",
    "title": "Introduction",
    "section": "",
    "text": "This page covers the functionality and theory behind the Travel Route Diversity program. Each subsection introduces an aspect of the program‚Äôs function and discusses how the program approaches the problem. A high-level summary is provided in the project README, and an introduction to the method‚Äôs theory is presented in the Motivation section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Introduction",
    "section": "Motivation",
    "text": "Motivation\nThis program provides an implementation of a network-based metric of transport network redundancy. Understanding route diversity is crucial for network planning, as it reveals how resilient a transportation system is to disruptions and how many alternative paths travelers have available\n\nTheory\n\n\nNetwork Redundancy Through Route Diversity\nCapturing the number of efficient routes and identifying shared links allows network planners to understand the redundancy of the network topology by considering route diversity under both normal and disrupted network conditions.\nRoute diversity can be measured in various ways. This program implements a ‚Äúnot-too-long‚Äù criteria to measure short detours from the shortest path that incur little additional cost. This approach recognizes that:\n\nTravelers don‚Äôt always take the shortest route - It may not even be possible for a traveler to know the true shortest route\nMultiple acceptable routes exist - Short detoured routes with acceptable additional cost may be considered with the same preference as the lowest-cost route\nDisruption resilience matters - During network disruption (through natural disaster or otherwise), a traveler may substitute a short detoured route for a disrupted primary route without incurring substantial additional costs\nShared links create vulnerabilities - If many routes share a single link, disruption to that shared link will have a substantial impact on the total number of available routes\n\n\n\nImplementation\n\n\nRoute Selection Criteria\nThe program considers only routes that consistently move the traveler away from the origin. Mathematically, this means including only links where:\n\\[ l_r(head_a)&gt;l_r(tail_a)\\]\nwhere \\(head_a\\) and \\(tail_a\\) are the head and tail of link \\(a\\), and \\(l_r(head_a)\\) and \\(l_r(tail_a)\\) are the cost from the origin \\(r\\) to the head and tail of the link, respectively. We assess the short detour routes by sub-setting the links is only reasonably more costly than the shortest path. This criterion is enforced using an elongation ratio, \\(\\tau^a_r\\), which typically ranges between 1.3 - 1.6 (this program uses 1.6 by default). Mathematically, the short detour criteria can be expressed as:\n\\[(1+\\tau^a_r)(l_r(head_a) - l_r(tail_a))\\geq l_a\\] where \\(l_a\\) is the cost of link \\(a\\).\n\n\nAssessing Link Usage\nBased on the number of effective routes calculated by the program, the number of efficient routes using a specific link can also be determined. This analysis is particularly useful for:\n\nDetermining link criticality - Understanding the importance of individual links in the network\nAssessing disruption impact - Determining how many routes will be affected if a link fails\nNetwork vulnerability analysis - Identifying critical infrastructure components\n\n\n\nCalculation Method\nWhile this functionality is not currently implemented in the program, it can be calculated using the results matrix:\n\\[\nN^{rs}_a=u(r,tail_a)\\times u(head_a,s)\n\\]\nwhere \\(N^{rs}_a\\) is the number of efficient routes between the OD pair ( \\(r\\), \\(s\\) ) that use link \\(a\\). \\(u(r,tail_a)\\) and \\(u(head_a,s)\\) are the calculated number of efficient routes between node pair \\((r,tail_a)\\) and \\((head_a,s)\\). If all traffic between the OD node pairs use link \\(a\\) then \\(N^{rs}_a\\) will be equal to \\(u(r,s)\\).",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#further-reading",
    "href": "index.html#further-reading",
    "title": "Introduction",
    "section": "Further reading",
    "text": "Further reading\nReaders interested in these methods or their interpretation are encouraged to read the paper from which these methods are based: https://doi.org/10.1016/j.trb.2018.05.014",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "usage.html#programmatic-integration",
    "href": "usage.html#programmatic-integration",
    "title": "Usage",
    "section": "Programmatic Integration",
    "text": "Programmatic Integration\nThe program can be called directly through function calls from your custom applications. This method provides full programmatic control and is ideal for automated workflows and integration into existing systems.",
    "crumbs": [
      "Usage"
    ]
  },
  {
    "objectID": "usage.html#command-line-interface",
    "href": "usage.html#command-line-interface",
    "title": "Usage",
    "section": "Command Line Interface",
    "text": "Command Line Interface\nThe program includes a CLI for direct user interaction. The command line interface features:\n\nBuilt-in usage prompts\nInput validation and error checking\nProgress indicators for long-running operations\n\nBoth integration methods provide access to the same core assessment functionality.\n\n\n\nProgram initialisation\n\n\n\n\n\nExample usage of the program",
    "crumbs": [
      "Usage"
    ]
  },
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Usage",
    "section": "",
    "text": "The program can be called directly through function calls from your custom applications. This method provides full programmatic control and is ideal for automated workflows and integration into existing systems.",
    "crumbs": [
      "Usage"
    ]
  },
  {
    "objectID": "usage.html#program-integration",
    "href": "usage.html#program-integration",
    "title": "Usage",
    "section": "",
    "text": "The program can be called directly through function calls from your custom applications. This method provides full programmatic control and is ideal for automated workflows and integration into existing systems.",
    "crumbs": [
      "Usage"
    ]
  }
]